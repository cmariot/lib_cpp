## Quick orientation — libftpp

This file helps an AI coding agent become productive quickly in this repository. Keep it short and concrete: where to look, how to build/test, and project-specific conventions.

### Big picture
- Purpose: a small C++ toolbox library that builds a static archive `libftpp.a` and exposes a single umbrella header `libftpp.hpp`.
- Structure:
  - `includes/` — public headers (organized by feature, e.g. `data_structures/`, `design_patterns/`).
  - `sources/` — implementation files compiled into `libftpp.a`.
  - `tests/` — unit tests + a small custom `libunit` framework under `tests/framework/`.
  - `Makefile` (top-level) drives build, tests and cleaning.

### Build & test workflow (exact commands)
- Build library: `make all` (produces `libftpp.a`).
- Build and run tests (auto-builds the small framework if needed): `make tests`.
- Run only existing test binary: `make test-only`.
- Cleanup all build artifacts and test logs: `make fclean`.

Notes: `make tests` will run `tests/generate_launcher.py` to auto-generate `tests/tests_launcher.cpp` — do not edit that generated file manually.

### Key implementation patterns & conventions
- Public entry: `libftpp.hpp` should include all needed public headers. Prefer adding headers to `includes/` and referencing them from the umbrella header.
- Templates: header+`.tpp` pattern is used (e.g. `pool.hpp` + `pool.tpp`). Implementation of templates lives in `.tpp` and is included at the end of the header.
- Pool pattern: `includes/data_structures/pool.hpp` implements an object pool type. Note `acquire()` returns a reference to `Pool<T>::Object` and lifetime semantics are manual (caller must call `release`). See `pool.tpp` for correct placement/new usage.
- Test discovery: `tests/generate_launcher.py` scans `tests/` for `extern "C" int <name>(void)` or functions ending with `_test` and generates `tests/tests_launcher.cpp` which registers tests with `load_test(...)`.
- Test logs: `tests/framework` creates per-test logs named `<function>_<test>.log`. `Makefile`'s `fclean` removes `*.log` files.

### Files to inspect first for common tasks
- Fix a build/compile issue: inspect `Makefile` + `includes/` + `sources/` where the failing symbol is defined.
- Add a new test: create `tests/<suite>/<your_test>.cpp` exposing `extern "C" int your_test(void)` and re-run `make tests` (the generator will pick it up).
- Change a template class: edit `<header>.hpp` and `<header>.tpp` together; `.tpp` must be included at the end of the header.

### Project-specific rules & gotchas
- C++ standard: the project uses `-std=c++23` in the top-level `Makefile`. Use modern C++ features accordingly.
- No external libs: the project is self-contained; tests link `libftpp.a` + `tests/framework/libunit.a` and do not rely on third-party packages.
- Lifetime / ownership: many lower-level utilities (Pool, DataBuffer) use manual construction/destruction and `operator new`/`delete`; be careful when changing ownership semantics.
- Generated files: `tests/tests_launcher.cpp` is generated by `tests/generate_launcher.py`. Don't edit it — change tests instead.

### Examples (copyable snippets)
- Add a test function signature (save in `tests/my_suite/my_test.cpp`):
  ```cpp
  extern "C" int my_feature_test(void) {
      // use ASSERT-like helpers in tests/test_utils.hpp
      return 0; // 0 == success for libunit launcher
  }
  ```
- Generate launcher (manual): `python3 tests/generate_launcher.py` (Makefile runs this for you before building tests)

### Integration points
- Top-level Makefile: compiles `sources/` -> `objects/` -> `libftpp.a` and orchestrates test framework build.
- `tests/framework`: contains the small test harness and log generation (see `create_log_file.cpp`).

If anything here is unclear or you want a shorter/longer version, tell me which area to expand (build, tests, templates, or the Pool/Buffer lifetimes) and I will iterate.
